##
## @section Global parameters
##

## @param global.imageRegistry - Global Docker image registry
## @param global.imagePullSecrets - Global Docker registry secret names as an array
##
global:
  ## E.g.
  ## imagePullSecrets:
  ##   - myRegistryKeySecretName
  ##
  imagePullSecrets: []

  ## @param global.waitForTCPDependency - Gets added as an init container to all containers
  ##
  waitForTCPDependency:
    image:
      name: ghcr.io/patrickdappollonio/wait-for:latest
      pullPolicy: IfNotPresent
      command: ["/wait-for"]
      args: ["--host=\"$(HOST):$(PORT)\"", "--verbose", "--every", "10s", "--timeout", "10m"]

##
## @section Common parameters
##

## @param nameOverride - String to partially override common.names.fullname template (will maintain the release name)
##
nameOverride: ""
## @param fullnameOverride - String to fully override common.names.fullname template with a string
##
fullnameOverride: ""
## @param clusterDomain - Kubernetes Cluster Domain
##
clusterDomain: cluster.local
## @param commonLabels - Add labels to all the deployed resources
##
commonLabels: {}
## @param commonAnnotations - Add annotations to all the deployed resources
##
commonAnnotations: {}

## @param common - Common options for the chart
##
common:
  ## @param common.baseDomain - The user facing (i.e. load balancer etc) URL prefix for the Bytesafe web interface and API.
  ##
  baseDomain: "example.com"

  ## @param common.dataEncryptionKey
  ##
  dataEncryptionKey: ""

  ## @param common.allowPrivateIpAddresses - Set to true to allow Bytesafe to connect to RFC1918 addresses
  ##
  allowPrivateIpAddresses: true

  ## @param common.smtp
  ##
  smtp:
    ## @param common.smtp.enabled
    ##
    enabled: false
    ## @param common.smtp.host
    ##
    host: ""
    ## @param common.smtp.port
    ##
    port: ""
    ## @param common.smtp.username
    ##
    username: ""
    ## @param common.smtp.password
    ##
    password: ""
    ## @param common.smtp.fromAddress
    ##
    fromAddress: ""

  ## @param common.telemetry - Send anonymous telemetry to https://telemetry.bytesafe.dev
  ##
  telemetry: false

## @param serviceAccount - Service account configurations
serviceAccount:
  bytesafe:
    ## @param serviceAccount.bytesafe.create Specifies whether a service account should be created
    create: true
    ## @param serviceAccount.bytesafe.annotations Annotations to add to the service account
    annotations: {}
    ## @param serviceAccount.bytesafe.name The name of the service account to use
    ## If not set and create is true, a name is generated using the fullname template
    name: ""
  postgres:
    ## @param serviceAccount.postgres.create Specifies whether a service account should be created
    create: true
    ## @param serviceAccount.postgres.annotations Annotations to add to the service account
    annotations: {}
    ## @param serviceAccount.postgres.name The name of the service account to use
    ## If not set and create is true, a name is generated using the fullname template
    name: ""
  redis:
    ## @param serviceAccount.redis.create Specifies whether a service account should be created
    create: true
    ## @param serviceAccount.redis.annotations Annotations to add to the service account
    annotations: {}
    ## @param serviceAccount.redis.name The name of the service account to use
    ## If not set and create is true, a name is generated using the fullname template
    name: ""

## @param bytesafe - ByteSafe configuration
bytesafe:

  ## @param bytesafe.replicaCount - Replicas to deploy
  ##
  replicaCount: 1

  ## @param bytesafe.image - Image configuration
  ##
  image:
    name: bytesafe/chart:latest
    pullPolicy: IfNotPresent

  ## @param bytesafe.service - Service configuration
  ##
  service:
    name: ""
    type: ClusterIP
    ports:
      http: 8081

  ## @param bytesafe.ingress - Ingress for bytesafe
  ##
  ingress:
    ## @param bytesafe.ingress.enabled - Set to true to enable ingress record generation
    ##
    enabled: false
    ## @param bytesafe.ingress.existingSecretName - Use an existing tls secret for this ingress resource
    #
    existingSecretName: ""
    ## @param bytesafe.ingress.selfSigned - Create a TLS secret for this ingress record using self-signed certificates generated by helm
    ##
    selfSigned: false
    ## @param bytesafe.ingress.pathType - Ingress path type
    ##
    pathType: ImplementationSpecific
    ## @param bytesafe.ingress.hostname - Default host for the ingress resource
    ## The default value is {{ .Values.common.baseDomain }}
    ##
    hostname: ""
    ## @param bytesafe.ingress.path - The Path to Nginx. You may need to set this to '/*' in order to use this with ALB ingress controllers.
    path: /
    ## @param bytesafe.ingress.annotations - Additional annotations for the Ingress resource. To enable certificate autogeneration, place here your cert-manager annotations.
    ## Example:
    ## annotations:
    ##    cert-manager.io/cluster-issuer: letsencrypt
    ##
    annotations: { }
    ## @param bytesafe.ingress.ingressClassName Set the ingressClassName on the ingress record for k8s 1.18+
    ## This is supported in Kubernetes 1.18+ and required if you have more than one IngressClass marked as the default for your cluster .
    ## ref: https://kubernetes.io/blog/2020/04/02/improvements-to-the-ingress-api-in-kubernetes-1.18/
    ##
    ingressClassName: "nginx"
    ## @param bytesafe.ingress.tls Create TLS Secret
    ## TLS certificates will be retrieved from a TLS secret with name: {{- printf "%s-tls" (include "domains.apiDomain.tls.secretName" .) }}
    ## You can use the ingress.secrets parameter to create this TLS secret or relay on cert-manager to create it
    ##
    tls: false

  ## @param bytesafe.persistence - Persistence configuration
  ##
  persistence:
    enabled: false
    existingClaim: ""
    storageClass: ""
    accessModes:
      - ReadWriteOnce
    size: 10Gi

  ## Other configurations
  ##
  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}
  resources: {}
  autoscaling:
    enabled: false
    minReplicas: 1
    maxReplicas: 100
    targetCPUUtilizationPercentage: 80
    targetMemoryUtilizationPercentage: 80
  nodeSelector: {}
  tolerations: []
  affinity: {}

## @param postgres - PostgreSQL configuration
##
postgres:

  ## @param postgres.external - Configuration of an external postgres database if enabled
  ## Make sure your user has access to the bytesafe database
  ##
  external:
    ## @param postgres.external.enabled - Defines if the deployment should use an external postgres database
    ##
    enabled: false
    ## @param postgres.external.host - Hostname of the external database
    ##
    host: ""
    ## @param postgres.external.port - Port of the external database
    ##
    port: 27017
    ## @param postgres.external.username - Username of the external database
    ##
    username: ""
    ## @param postgres.external.password - Password of the external database
    ##
    password: ""
    ## @param postgres.external.adminUsername - PostgreSQL user used for initial database setup. Needs adequate privileges to create databases, tables, index etc
    ##
    adminUsername: ""
    ## @param postgres.external.adminPassword - Password for the adminUsername
    ##
    adminPassword: ""

  ## @param postgres.image - Image configuration
  ##
  image:
    name: bitnami/postgresql
    pullPolicy: IfNotPresent

  ## @param postgres.persistence - Persistence configuration
  ##
  persistence:
    enabled: false
    existingClaim: ""
    storageClass: ""
    accessModes:
      - ReadWriteOnce
    size: 8Gi

  ## @param postgres.service - Configuration of the mongodb service
  ##
  service:
    name: ""
    type: ClusterIP
    port: "5432"

  ## Other configurations
  ##
  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
  resources: {}

## @param redis - Redis configuration
##
redis:

  ## @param redis.external - Configuration of an external redis database if enabled
  ##
  external:
    ## @param redis.external.enabled - Defines if the deployment should use an external redis database
    ##
    enabled: false
    ## @param redis.external.host - Hostname of the external database
    ##
    host: ""
    ## @param redis.external.port - Port of the external database
    ##
    port: "6379"
    ## @param redis.external.username - Username of the external database
    ##
    username: ""
    ## @param redis.external.password - Password of the external database
    ##
    password: ""

  ## @param redis.persistence - Persistence configuration
  ##
  persistence:
    enabled: false
    existingClaim: ""
    storageClass: ""
    accessModes:
      - ReadWriteOnce
    size: 8Gi

  ## @param redis.service - Configuration of the redis service
  ##
  service:
    name: ""
    type: ClusterIP
    port: "6379"

  ## Other configurations
  ##
  podAnnotations: {}
  podSecurityContext: {}
  securityContext: {}
  resources: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}